---
title: 'C# 设计模式导览'
date: 2020-03-14 02:20:58
category: 设计模式
tags: .net
id: csharp-design-pattern
---

# 前言

工作一段时间后才发现设计模式的重要性，实现同样功能的代码，人家的代码看着如此舒适，却又说不出好在哪里😟，想必是差在内功了。大三准备面试时也粗略学过一段时间设计模式，但因为缺乏工程经验，没有深切体会，现在重新捡起温习。

本系列博客主要参考刘伟博士著作的[《C#设计模式（第2版）》](https://blog.csdn.net/LoveLion/article/details/79601850)一书👍，结合本人的实践与思考而写成，同时参阅网络上各位大佬的总结，不再列出。

🍺源码汇总： https://github.com/AkiyaX/CSharpDesignPattern

![《C#设计模式》 - 封面](https://img-blog.csdn.net/20180318164255870)


# 设计模式概览

最早将模式思想引入软件工程方法学的是Gang of Four（GOF）自称的四位软件工程学者，分别是Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides，他们在1994年归纳发表了23种在软件开发领域较为常用的设计模式。GOF对设计模式的定义：

>**设计模式**是在特定环境下为解决某一通用软件设计问题提供的一套定制解决方案，该方案描述了类和对象之间的相互作用。
>**Design patterns** are desriptions of communicating objects and classes that are custormized to solve a general design problem in a particular context.

## 创建型模式

*此类模式主要用于创建对象*

[**简单工厂模式**](https://akiyax.github.io/simple-factory-pattern/)（Abstract Fatory Pattern）：定义一个工厂类，它可以根据参数不同返回不同类的实例，被创建的实例通常都具有共同的父类。

[**工厂方法模式**](https://akiyax.github.io/factory-method-pattern/)（Factory Method Pattern）：定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到子类。

[**抽象工厂模式**](https://akiyax.github.io/abstract-fatory-pattern/)（Abstract Fatory Pattern）:提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。

**建造者模式**（Builder Pattern）：将一个复杂对象的构建与它的表示分离，使得同样的构造过程可以创建不同的表示。

**原型模式**（Prototype Pattern）：使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。

**单例模式**（Singleton Pattern）：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。

## 结构型模式

*此类模式主要用于处理类或对象的组合*

**适配器模式**（Adapter Pattern）：将一个类的接口转换成客户希望看到的另一个接口，适配器模式让那些接口不兼容的类可以一起工作。

**桥接模式**（Bridge Pattern）：将抽象部分与它的实现部分解耦，使得两者都能够独立变化。

**组合模式**（Composite Pattern）：组合多个对象形成树形结构以表示具有部分——整体关系的层次结构，组合模式让客户端可以统一对待单个对象和组合对象。

**装饰模式**（Decorator Pattern）：动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰器模式提供了一种比子类更加灵活的替代方案。

**外观模式**（Facade Pattern）：为子系统种的一组接口提供一个统一的入口，这个接口使得这一子系统更加容易使用。

**享元模式**（Flyweight Pattern）：运用共享技术有效地支持大量细粒度对象的复用。

**代理模式**（Proxy Pattern）：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。

## 行为型模式

*此类模式主要用于描述类或对象如何交互和怎样分配职责*

**职责链模式**（Chain of Responsibility Pattern）：避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求；将接受请求的对象连接成一条链，并且沿着这条链传递请求，指导一个对象能够处理它为止。

**命令模式**（Command Pattern）：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。

**解释器模式**（Interperter Pattern）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

**迭代器模式**（Iterator Pattern）：提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露该对象的内部表示。

**中介者模式**（Mediator Pattern）：定义一个对象来封装一系列对象的交互。中介者模式使各对象之间不需要显式地互相引用，从而使其耦合松散，而且让你可以独立地改变它们之间的交互。

**备忘录模式**（Memento Pattern）：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。

**观察者模式**（Observer Pattern）：定义对象之间的一种一对多依赖关系，使得每当一个对象状态覆盖发生改变时，其相关依赖对象皆得到通知并被自动更新。

**状态模式**（State Pattern）：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。

**策略模式**（Strategy Pattern）：定义一系列算法，将每一个算法封装起来，并让它们可以互相转换，策略模式让算法可以独立于使用它的客户变化。

**模板方法模式**（Template Method Pattern）：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

**访问者模式**（Visitor Pattern）：表示一个作用于某对象结构中的各个元素的操作，访问者模式让你可以在不改变各原色的类前提下定义这些元素的新操作。

# 面向对象设计原则

## 单一职责原则

> 一个对象应该只包含单一的职责，并且该职责完整地封装在一个类中。

在软件系统中，一个类承担的职责越多，它被复用的可能性就越低。单一职责原则是实现高内聚、低耦合的指导方针。

```cs
class CustomerDataChart
{
    public Connection GetConnection()
    {
        //...
    }

    public List<Custormer> FindCustomers()
    {
        //...
    }

    public void CreateChart()
    {
        //...
    }

    public void DisplayChart()
    {
        //...
    }
}
```

例如这个类承担了太多的原则，即包含连接数据库，又包含与图表生产和显示相关的方法。

## 开闭原则

>软件实体应当对外扩展开放，对修改关闭。

尽量在不修改原有代码的情况下进行功能扩展。

## 里氏代换原则

>所有引用基类的地方必须能透明地使用其子类的对象。

在软件中将一个基类对象替换成它的子类对象，程序不会产生任何错误和异常，反之不成立。

## 依赖倒转原则

>高层模块不应该依赖低层模块，它们都应该依赖抽象，抽象不应该依赖于细节，细节应该依赖于抽象。

简单说就是，要面向接口编程，而非面向实现编程。

在实现依赖倒转原则时，需要针对抽象层进行编程，而将具体类的对象通过依赖注入（Dependency Injection, DI）的方式注入其他对象中。

在大多数情况下，开闭原则、里氏代换原则、依赖倒转原则会同时出现，**开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段**。

## 接口隔离原则

>客户端不应该依赖那些它不需要的接口。

## 合成复用原则

>优先使用对象组合，而不是继承来达到复用目的。

合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分，新对象用过委派调用已有对象的方法发到复用功能的目的。简言之，复用是要尽量使用组合/聚合关系，少用继承。

## 迪米特法则（最少知识原则）

>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。

迪米特法则要求一个软件实体应当尽可能少地与其他实体发生相互作用。如果一个系统符合迪米特法则，那么当其中一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。