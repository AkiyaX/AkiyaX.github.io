---
title: 'C#设计模式[2] - 工厂方法模式'
category: 设计模式
tags: .NET
date: 2020-03-19 23:04:23
id: factory-method-pattern
---

# 概述

仍然使用上一篇简单工厂模式中的例子，在水果农场中，`FruitFactory`可以返回具体的水果实例，包括🍎和🍊等等，但是如果这个水果农场新增了一种水果，比如🍉，那么我们除了新增🍉类以外，还需要修改`FruitFactory`的代码，使得整个设计违反了[开闭原则](https://akiyax.github.io/csharp-design-pattern/#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99)。

因此我们不再使用一个`FruitFactory`来统一负责所有水果实例的创建，而是交给专门的工厂子类去完成。

>**工厂方法模式**：定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化，工厂方法模式让一个类的实例化延迟到其子类。

使用频率：★★★★★

# 结构与实现

相对于简单工厂模式，工厂方法模式将Factory（工厂角色）拆分成了

- AbstractFactory（抽象工厂角色）
- ConcreteFactory（具体工厂角色）

另外还包括

- Product （抽象产品角色）
- ConcreteProduct （具体产品角色）

一共4种角色。

Menlo, Monaco, Consolas, Courier New, monospace;


{% plantuml %}

    !includeurl https://raw.githubusercontent.com/AkiyaX/AkiyaX.github.io/hexo/src/theme.puml   

    package ConcreteFactory <<Folder>> {
        class AppleFactory
        class OrangeFactory
    }

    package ConcreteProduct <<Folder>> {
        class Apple
        class Orange
    }

    abstract class Fruit {
        + void MethodSame()
        + {abstract} void MethodDiff()
    }
    class Apple {
        + void MethodDiff()
    }
    class Orange {
        + void MethodDiff()
    }
    
    interface FruitFactory {
        + Fruit GetFruit()
    }

    class AppleFactory {
        + Fruit GetFruit()
    }

    class OrangeFactory {
        + Fruit GetFruit()
    }

    Apple --|> Fruit
    Orange --|> Fruit
    FruitFactory <|-- AppleFactory
    FruitFactory <|-- OrangeFactory
    AppleFactory ..> Apple : <<create>>
    OrangeFactory ..> Orange : <<create>>

    

{% endplantuml %}


# 优缺点

优点：

缺点：

# 适用场景